### Лекции 23, 24

### Операторы
* :=
* ветвления (if,  case/switch)
* циклы (while, repeat, for)
* заменители goto (break, continue, return)

Цикл:
* Подготовка данных
* Проверка данных (отсюда может быть выход из цикла)
* Обработка

```C
int ch;
while ((ch = getchar())!=EOF)
	processData();
// если бы присваивание не было операцией, то пришлось бы делать так:
int ch;
ch = getchar();
while (ch!=EOF) {
	processData();
	ch = getchar();
	// дублирование кода!!!
}
// проверка данных, так например в Паскале, перед чтением надо проверять готовность данных, иначе чтение не пройдет и все свалится
while (checkData()) {
	inputData();
	processData();
	// тут мы не уходим от проблемы дублирования кода
}
```
Fortran, PL-1:
ON OVERFLOW <operators\>
ON ENDFILE  <operators\>  --- авария, попытка прочитать за концом файла, оператор выхода из цикла
*C:*
```C
for(;;) { // бесконечный цикл
	prepareData();
	if (!ready) break;
	processData();
}
```
В Modula 2 оставили операторы из Паскаля и добавили бесконечный цикл:
```Modula 2
LOOP
	// operators
	IF B THEN EXIT // выход из цикла
END
```
*Swift:*
```Swift
while B {
	// operators
}
repeat {
}
```
*Go:*
```Go
// есть только цикл for
for init; cond; post {
	//
}
for i:=0; i <= N; i++ { // for
	//
}
for i <= N { // while
	//
}
for { // infinite
	//
}
```
> Программистам Microsoft платят за строки, поэтому пишем, как Маяковский, --- столбиком!
> {
>     dosomething();
> }

*Python:*
```python
while B:
	pass #
for i in range(0, N): # в смысле foreach
	pass #
for i in stdin.read():
	pass #
# в python есть if, но нет switch
# используется словарь, как и в С# встроенный в библиотеку
# значением словаря может быть лямбда
# для цикла for есть оператор else
for i in range(0, N):
	pass # если тут будет break, то else не выполнится
else:
	pass # тут может быть какая-то очистка ресурсов, например 
```
> Представьте себя маленьким симпатичным интерпретатором... Вот в 90-х у программистов шиза была --- представлять себя маленькой операционной системой.

*Modula 2:*
```Modula 2
for i:=e1 to e2 [step3] do S
```
Появление интерфейсов:
набор методов, данных.
В С++ --- полностью виртуальный класс
```C++
class ISet {
public:
	virtual bool In(T x) = 0;
	...
	virtual ~ISet() {} /* обязательно надо написать тело, он не может быть чисто виртуальным. 
	Конструктор может быть сгенерированным, но деструктор - нет, иначе он будет не виртуальным.*/
};
```
*C#:*
```C#
interface IEnumerable { // все, что поддерживает интерфейс GetEnumerator, - коллекция
	bool MoveNext();
	Object Current; get;
	void Reset();
}

// foreach(T x in C) S // С - коллекция, :
Iterator it = C.GetEnumerator();
while (it.MoveNext()) {
	x = it.Current;
	...
}
```
```C#
interface IDisposable {
	void Dispose(); // уничтожение элемента
}

Image im = Image.FromFile("C:\\i.jpg");
// мы точно не знаем, когда выполнится деструктор
/* здесь может возникнуть исключение, поэтому нам нужна гарантия удаления объекта: */
Image im = Image.FromFile("...");
try {
	processImage(im);
} finally {
	((IDisposable)im).Dispose(); // гарантированное выполнение
}
// если аварийное завершение, то все равно будет вызван деструктор
im.Dispose(); // здесь явное удаление
```
```C#
using (Image im = Image.FromFile("...")) {
	processImage(im);
	// using блок превращается в try-finally, для im будет должным образом вызван Dispose, если im поддерживает этот интерфейс (иначе - ошибка)
}
```
try-finally присутствует во всех объектно-референциальных ЯП.
*Java:*
```Java
// foreach(T x in C) S
for (T x : C) S // C поддерживает коллекцию
```
```C++
int a[] = {1, 2, 3, 4, 5};
for (int x : a) {...}
for (auto x : a) {...}
for (auto &x : a) {//передача по ссылке, чтобы не копировать каждый раз, можно менять элементы}
for (const auto &x : a) {// передача по ссылке, менять нельзя}
```
*Go:*
```Go
// если это коллекция, то к ней применимо ключевое слово range
for k, v := range C { // итератор по коллекции
	// k - ключ, v - значение
	// если массив, то k - индекс, v - значение
	// если строка, то k - позиция от начального байта, v - rune (значение в unicode)
	// если map (входит в базис), k - ключ, v - значение
}
// map[тип ключа] тип значения
d map[string] string
for _, v := range C { // фактически, foreach

}
```
*Swift:*
```Swift
for x in C {

}
```
### Средства развития

* Подпрограммы (абстракция алгоритма)
* Новые типы данных
* Модули

##### Средства защиты
* Инкапсуляция
* что-то еще

Темы:
* Передача данных в подпрограммах
* Передача управления (сопрограммам и подпрограммам)
* Функциональные ТД 

#### Передача данных
Динамическое связывание
Фактическаие параметры и формальные

В языке Ada в функциях запрещена модификация параметров (переменные только in, не inout, как было в языке Green). Процедуры могут менять параметры, но не имеют возвращаемого значения.
Не надо менять в функиях глобальные переменные!

**InOut семантика**
Способы передачи параметров (связывание параметров):
* *In семантика* --- параметр не меняется
* *Out семантика* --- выходной параметр, изначальное определение параметра не требуется
* *InOut семантика* ---  входной параметр изменяется
В идеале --- просто сформулировать InOut семантику, а выбор сособа передачи параметров передать компилятору.
*Ada:*
```Ada
procedure P (X : in T, I : inout T, Z : out T);
```
Способы (значения фактических и формальных параметров хранятся в стеке):
1. По значению (in)
	Фактические параметры копируются в формальные
2. По результату (out)
	Значения формальных параметров копируются в фактические
3. По значению/результату (inout)
	Фактические параметры копируются в стек перед вызовом, а по возвращении формальные копируются в фактические: вычисляются значения и места размещения фактических параметров, значения присваивают формальным параметрам, после выполнения тела подпрограммы конечные значения формальных параметров копируются обратно в места размещения, вычисленные ранее.
4. По адресу/ссылке
	Передаем либо адрес, либо процедуру вычисления адреса. Наиболее универсальный, с его помощью можно реализовать все 3 семантики. В Fortran изначально все параметры передавались так.
5. По имени (by name)
	
> В старых вариантах лекций, переписывая с аудио, кто-то писал "по значению результата"

В современных ЯП мы специфицируем способ передачи параметров (по ссылке, по значению).
```Ada
procedure P(X, Y : inout T) is
begin
	X := newval1;
	Y := newval2;

end;
// Проблемы возникают, когда передаем одно и то же значение:
P(A, A); // результат будет зависеть от реализации компилятора
P(A(i), A(j));
// что если внутри процедуры будет аварийная ситуация? второе значение может оказаться неопределенным
```
C: f(i++, ++i) --- нестандартизовано
В С++ по умолчанию все передается по значению, еси специфицируем --- то по ссылке.

*C#:*
```C#
void f(Object o) {}
struct C {...}
...
C c = new C();
f(c); // неявно происходит упаковка и распаковка объекта
void f(T x) {} // если объект х - интерфейс, объект и тд, то по ссылке, иначе по значению
T a = new T();
```
Передача параметров по значению и по ссылке (ссылку тоже можно передать по ссылке)
```C#
void f(ref int i) {
	...
	i = 5;
	...
}
int i;
f(ref i); // ошибка времени выполнения, ref - inout семантика, параметр должен быть определен!
f(out i); // задаем out семантику, i может быть неопределен
int a = 1;
f(ref a);
// Классы обертки:
int Int32.Parse(string s); // если там может быть не число, то:
bool Int32.TryParse(string s, out i); // не требуется изначального определения i, но i надо описать где-то
// чтобы избавиться от этого, внутри условного оператора можно объявить i = TryParse
```
```C#
void Init(out X a, out X b, out X c) {
	a = new X();
	b = new X();
	c = new X();
}
Init(out a, out b, out c);
```
**thunk** --- передача по имени
some language:
```
procedure P(X byname T)
	X := 0
T a;
P(a); 
```

В Algol68 нельзя написать корректно работающую программу swap
```
procedure swap(x, y: byname int)
	t : int;
begin
	t := x;
	x := y;
	y := t;
end

int a[10];
int i = 0;
swap(a[i], i); // thunk для i вычисляет адрес i, для a[i] - адрес, на основе i. будет работать некорректно
```
Перегрузка оператора присваивания 
```C++
X &operator=(const X &rhs) {
	if (&rhs == this)
		return *this; // нельзя удалять старые данные, вдруг мы присваиваем самого себя
	// здесь можно удалять старое и делать глубокое присваивание rhs
}
```
В Lisp параметры как-то передаются, это не так важно (ничего не меняется, никаких проблем не возникает из-за отсутствия понятия состояния).

#### Передача управления
*Подпрограмма*
Caller (глваная программа) -> Call (вызов) -> Callee (вызываемый) -> Return -> .Call (возврат в точку вызова)-> продолжение программы
*Сопрограмма* (похоже на два потока управления)
P1 -> Resume P2 -> P2 -> Resume P1 -> .Resume P2 (возврат в точку) -> <...> -> Resume P2 -> P2 -> Resume P1 -> .Resume P2
