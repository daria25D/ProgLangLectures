### Лекции 3, 4 10.09.19
#### Примеры парадигм программирования (ПП)
Все парадигмы зародились примерно в 50-е.

1. Императивная (процедурная) 
ООПП (объектно-императивн).
 Сейчас доминирует.
 Состояние, методы (определяют поведение объекта), алгоритмы. Сильно опирается на состояние.
 Изобретатель парадигмы — Алан Кей (Alan Key). SamllTalk — 1975. Главное в ООП (по Алану Кею) — посылка сообщений и их динамическая обработка. 
 Императивное программирование зашло в тупик? (70-е)
2. Функциональная
3. Логическа

Начнем с императивной ПП.

#### C
ОС написаны на С (иначе пришлось бы прогать на ассемблере, С заменил его). 
В 2000-е ассемблерные программы начали переписывать на С++ 
Страуструп: 
> C++ is better C

```C
#include <stdio.h> 
// контекст трансляций, информация для компиялтора, имена (набор неких имен, неопределенных в программе, но используемых)
#include <stdlib.h> 
/** имя — идентификатор (с точки зрения императивных ЯП), таким образом здесь — набор стандартных идентификаторов (integer, printf...), так в Pascal
в компиляторе C НЕТ стандартного контекста!!! int, float и т.д. не идентификаторы, а ключевые слова. Так же во многих современныз ЯП.
передаем headers <> — стандартная билиотека. Наши headers — " ". Далее — обработка препроцессором. Явное импортирование контекста.
слово extern — дурной стиль!!! Не употребляется в С (но вот в ассемблере можно), Эвы не понимаете С, если используете", внешнему имени должно тогда соответствовать корректное объявление (но должно быть определение)
*/
extern int i; // m1.c — extern из m2.c
/**

*/

double i; /** m2.c — здесь double => может быть ошибка, несоответствие размеров. Даже если соответствуют, то тоже плохо. Нет контроля за межмодульными связями. Определение и объявление могут не соответствовать. Таким образом, весь интерфейс ДОЛЖЕН БЫТЬ в m1.h!!!
*/
```

И недостаток, и достоинство в том, что С — язык ассемблера. Контроль межмодульных связей отсутствует. Дальнейшее развитие для С++ 20 — обсудить понятие модуля, но тогда будет ли это С++?

```C
#include <stdio.h>
#include <stdlib.h>
#define BUF_SIZE 1024; 
/** пишется большими буквами, так как это константа препроцессора, нужно это выделить (препроцессорные имена — не совсем имена в общем понимании, вместо BUF_SIZE будет подставлено 1024, переменная не может быть объявлена еще) Имена переменных, тэги структур и препроцессорные имена — все виды имен в С. Тэги структур: область видимости как для переменных препроцессора */

struct bar {
	struct foo {int i;} 
	i;// область видимости типа структуры отсюда и ниже
} c;
int i;
struct foo c1;

/** struct time: time(...) */

char buffer[BUF_SIZE];

/** в первой версии языка С — если функция ничего не возвращала, то по умолчанию она возвращала int:
main(argc, char ** argv) {} */

int main(int argc, char ** argv) // или int main()
{
	int ch;
	int index = 0;
	// ТАК ПИСАТЬ НЕ СТОИТ!!!
	
		buffer[index++] = ch; 
		/** может быть buffer override — уязвимость программы. Таким образом хакеры, зная код, могут перетирать память за буфером и вставлять свой вредоносный код. 
		SQL-injection — вставка вредоносного SQL кода. Поэтому сейчас производится предварительная интерпретация SQL запроса, строится дерево, и только потом производится 		  вставка. */
		/** В С есть функция, которую нельзя употреблять! — gets(char *buf), нет никакого предохранения. Есть функции с '_s' — значит, что они безопасны. Используйте fgets(...), gets_s(...)
		*/
		
	}
	while ((ch = getchar()) != EOF) {
		if (index == BUF_SIZE) {
			fprintf(stderr, "...");
			exit 1;
		}
		buffer[index++] = ch;
	}
}
```
Но это неполное решение, могут быть строки только до 1024.
```C
#include <stdio.h>
#include <stdlib.h>
#define BUF_SIZE 1024; 
char * buffer;
int size;
int main(int argc, char ** argv) {
	int ch;
	int index = 0;
	buffer = (char *) malloc(BUF_SIZE);
	size = BUF_SIZE;
	while ((ch = getchar()) != EOF) {
		if (index == size) {
			realloc( 
			/** увеличивать в 2 раза, но проблема realloc — нужны непрерывные куски памяти, поэтому нужна проверка. Не надо выделять size+1, иначе будет фрагментация памяти. В других ЯП есть сборщики мусора: работа с памятью прекращается, находится то, что не нужно (может выполнятся в фоновом режиме, параллельно) и начинается дефрагментация. Указатели замораживаются (но можно явно указать, чтобы не замораживались, как например в С#).
*/
// С runtime — стандартная библиотека С (нет такого, как в Java — JRT)
		}
		buffer[index++] = ch;
	}
	for (index; index >= 0; index--) 
		printchar(buffer[index]); 
		
	// будет работать очень медленно, в каждой итерации — системный вызов, а это прерывание, замедляет программу.
}
```
В С89 появился еще VLA — variable length array.
Еще минусы С:

> В С совершенно уродский синтаксис.

И:
> Если программа на С не будет эффективнее, чем на любом другом ЯП, то вы неправильно написали программу на С.

? для ассемблера ?
$$\frac {T_L}  {T_{AS}} > 1$$
$$T_{AS} > T_L$$
Для С (L — любой ЯП):
$$ \frac {T_C} {T_L} < 1$$

#### C\#
Все на свете — класс.
```C#
public class Program{}
```
Есть методы экземпляра и методы класса.
```C#
public void Main(Sring[] args) // язык со строгой типизацией
{
	String s = System.Console.In.ReadToEnd(); // String — из стандартного контекста, string — ключевое слово
	/** до конца файла. Аллокация памяти, алгоритм — какой-то, неизвестно, как именно, универсальный алгоритм может быть неэффективен в частных случаях
	*/
	/** С: можно модифицировать quicksort, вместо среднего элемента массива — медиана трех (в среднем будет хуже, но для некоторых частных случаев, когда надо перебросить часть массива полностью, более оптимален)
	*/
	for (int i = s.Length - 1; i >= 0; i--) 
		System.Console.Write(s[i]); // такой код считается достаточно низкоуровневым
	/** Идея: просто указать, что делать с объектом, т.е. не указывается цикл, а указывается последовательность, в каком порядке и что с ней делать. Но метода s.Reverse для строк нет, нашлось только в PHP. Но reverse есть для массива! (не зависит от семантики, игнорируется способ записи символов e' и прочих). Строка в С#  — immutable, а массив — mutable. Должна быть функция преобразования строки в массив*/
	char[]c = s.ToCharArray();
	c.Reverse();
	System.Console.Write(c);
	
	/** Проблема класса — он и модуль, и тип данных. Иногда удобно, а иногда и нет.
	System — пространство имен
	Console — имя класса из System
	In — статический член класса Console
	У класса TextReader есть метод ReadToEnd
	Получается дуализм
	*/
	/** нигде нет подключения модулей: это можно сделать в опциях проекта*/
}
```


#### Python

Задумываался как просто "чемоданчик с инструментами".
Интерпретируемый язык.
Для него работает REPL — Read Evaluate Print Loop.
Интерпретатор берет какую-то часть (оператор) и выполняет его.
В Питоне короткие программы (для простейшей нужо два оператора, один из которых import)
```python
import sys

raw = sys.stdin.read()
l = [c for c in raw] # list comprehension
l.reverse() # ничего не возвращает (проверено в интерпретаторе), у лектора l.reverse сразу было в join
print(''.join(l)) # раньше в python2 был оператором, потом в python3 стал функцией
```

```python
# a= ...

b = a[0:len(a)] # копирование всего массива
b = a[:-1] # копирование без послледнего элемента
# правильное "короткое" копирование:
b = a[:]

```

Можно коротко написать:
```python
import sys
print(sys.stdin.read()[::-1]) #[::-1] — reverse
```

> В Lisp: (abc) воспримется как один символ, поэтому (print reverse read) выведет (abc). Надо подавать как (a b c).

#### C++

```C++
#include <iostream>
#include <algorithm>
#include <vector>
#include <iterator> //  содержит полезные итераторы (итераторы работы с вводом-выводом и класс inserter: для вставки в начало/конец нужной структуры)
// для вектора существует только back_inserter, в целях эффективности
using namespace std;
int main() {
	vector<char> v;
	copy(istream_iterator<char>(cin) /** аналог функции begin()*/, istream_iterator<char>(), back_iterator(v));
	copy(v.rbegin(), v.rend(), ostream_iterator<char>(cout));
	return 0;
}
```


#### Go
Есть интерфейсы и динамическая сборка мусора, нет ООП. Модульный язык. Стандартный контекст достаточно маленький, все, что нужно, должно быть импортировано.
```Go
package main
import ("fmt"; "io/ioutil"; "os"; "strings") //  модули
func main() {
	rdr := os.Stdin // автообъявление с помощью :=, тип выводится из типа правой части
	// в С++ появилось auto и decltype()
	b, err := ioutil.ReadAll(rdr) // вернется строка (последовательность байтов) и признак ошибки, если есть
	if err != nil {
		panic("bad input")
	}
	s := string(b)
	x := string.Split(s, "")
	for i := len(x) - 1; i >= 0; i-- {
		fmt.Print(x[i])	
	}	
}
```
