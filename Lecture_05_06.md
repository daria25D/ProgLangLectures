### Лекция 5, 6 17.09.19

#### Обобщенная парадигма программирования
Входит в императивную парадигму. Есть понятие состояния. Суть — статическая параметризация типов данных:

* надежно, так как типы контролируются во время трансляции,
* эффективно

В Питоне не может быть статической параметризации (там динамическая, так как на этапе трансляции типов еще нет, есть объекты и их взаимодействие).

#### Функциональная парадигма 

#### Лисп
1959
Pure Lisp — образец функционального программирования. Из Лиспа выкинули все, связанное с процедурностью (так как иначе — мультипарадигмальность).
List Processing
Но на самом деле — язык обработки S-expression, символьное вырадение (список — самый частый представитель).
Самый популярный стандарт Лиспа — Common Lisp.

```Lisp
SET Q EXPR // Чистое понятие состояния
```

* **Данные**
    Крайне простые структуры данных, с котроым он работает.
    Атом — данные, не обладающие внутренней структурой. 
    Символ — идентификатор + некоторое расширение (а, +, Т...).
    Базовые лексемы — () . ; остальное — символы. 
    Отсутствует понятие "строка".
    S-выражение (точечная пара): a.b, где a и b — либо атомы, либо S-выражения.
   S-выражения — 2 ячейки, в одной указатель на первую переменную, во второй — на другую (либо на таблицу атомов, либо на другой список/S-выражение).
   CAR — head списка
   CDR — tail списка
   Специальный атом — пустой список, нулевой указатель, можно рассматривать как список (одновременно и атом, и список).
   Список — S-выражение особого вида, где последний элемент — пустой список (2 ячейки, первая — указатель на спиок/что-то там еще, вторая — пустой список).
   Фактически, список в Лиспе — это дерево.
 Левая часть может быть либо атомом, либо списком. Правая часть всегда ссылка на список.
```Lisp
a.NIL // короткое обозначение — (а)
a.(b.NIL) // указатель на а . указатель на ( указатель на b . пустой список)
```
    

* **Операции**
Вычисление атомов:
первым символом должен стоять тот, с которым связано функциональное значение, а дальше: 
``` 
(+, a1, ..., an)
```
Если нет побочных действий, то порядок вычисления неважен. 
Результат вычисления — то, что выдает функция, например, для +: список из одного элемента: (+ 1 2 3 4 5) -> (15)
Должен быть набор встроенных функций:
```
(CAR S) // head of S, либо атом, либо список
(CDR S) // tail of S, всегда список (пустой или нет)
(read) // список из результата функции read
(1) // список из одного символа
(abc) // abc воспринимается как один символ
(a b c) // список из трех элементов
reverse(read) // если read вернет список, то будет reverse от списка, если атом, то атом
print(reverse(read)) // вывод списка в обратном порядке
(NULL S) // если S — пустой список, то выдаст Т, если ложь, то пустой список (аналог False)
(COND (S1) res1
	  (S2) res2
	   ...
	  (Sn) resn
) //вычисляется, пока не сработает одно из условий
(COND (S1) res1
	  (T)  res2 
) // аналог if, для простоты будем использовать (IF (S1) res1)
(append S1 S2) // объединение списков (сначала S1, потом идет S2 в конец). Можно записать через cons (?)
(cons a.b) // конструирование списка
(ATOM S) // атом или нет

```


#####Позиции рассмотрения языка:

* **Технологическая**: 
    должен отражать те или иные технологические потребности в зависимости от технологической ниши языка (некоторой отрасли яп), например, системное программирование (здесь лидирует С, вытеснив ассемблер), научно-технические вычисления (лидирует/-овал Fortran, теперь вытесняется R, matlab).
* **Авторская**
   добавление какой-либо функциональности (модули, динамическое программирование) при необходимости.
* **Реализаторская**
* **Семиотическая**
* **Социальная**

RAD — rapid application development
REPL — read-evaluate-print


**Функция reverse на Lisp**

```
(defun Sym (Sym1 Sym2 ... Symn) S) //Symj — аргументы
(defun reverse1(S) 
	(IF (NULL S) ()
	    (append (reverse(CDR S)) (CAR S)) // тут все упадет на CAR, если там атом, так как аргументы append — 2 списка, поэтому надо вот так:
	    (append (reverse(CDR S)) (cons (CAR S)))
	)
) // это все будет долго и неэффективно работать, для reverse должно быть достаточно одного прохода (с вспомогательной функцией shift):
(defun shift(l r) // берет голову l и переносит в r
	(IF (NULL l) r
	    (shift (CDR l) (cons (CAR l) r))
	)
)
(defun reverse1(S) 
	(shift S ())
)
	
```
