### Лекция 7, 8 24.09.19
#### REFAL
60-е годы, придуман физиком Турчиным.
Нужен был формализм для обработки сивмольной информации. Во всех смыслах "Марковский" язык (алгоритмы Маркова).
В языке: либо символ, либо выражение (с номерами, чтобы отличать их).
```
s.n // символ    
s.1    
e.m // выражение    
e.2    
s.1 e.1 s.1 // образец. такому образцу соответствует строка, которая начинается и заканчивается на один и тот же символ. справа должно стоять то, как выражение преобразовывается: ? = ?? - поле ввода = преобразование
```

```Refal
$ENTRY GO
{
	 = <Prout  < REVERSE <card>>>; // пустое поле ввода
}
REVERSE
{
	// не пустая строка => символ и произвольная строка (мб пустая):
	s.1 e.1 = < REVERSE e.1> s.1 /; // / — завершение
	// если пустая строка:
	 = ;
}
```

#### Базисные понятия ЯП
(Для всех парадигм)

1. Данные 
2. Операции 
3. Связывание

##### Данные и операции
Программы обрабатывают данные. В каждом ЯП есть понятия данных и операций (самые базисные понятия, для общности ЯП их сложно уточнить, так как суть весьма прозрачна и понятна).
Для каждого конкретного ЯП эти понятия можно определить очень точно.

*Немного о С:*
Простой в плане понятий данных и операций, но стандарт очень сложен, не все реализации, например, гарантируют "2+2=4" (представим двухбитный процессор: 2+2 вызовет переполнение). Не гарантируется правильность вычисления: 
```
l(i++, ++i)
```
будет зависеть от компилятора (порядок вычисления). 
```C
p != NULL && *p > 0
```
 — ленивые вычисления, пример зависимости от порядка вычислений.
 
*В С:*
```
strlen(s) // операция
```
*В С++:*
```
// basic_string<char> 
string.size() // выдаст данные 
```
То, что является данными, может являться результатом выполнения каких-то операций.
Ленивые вычисления (lazy evaluation) — вычисление (взятие данных из структуры и тд) происходит ровно в тот момент, когда это нужно.
Например, в python2:
```python2
range(N) # список от 0 до N - 1 [0; N)
xrange(N) # генератор (сущность)
```
В python3 уже нет xrange, он перешел в range. Список можно получить как list(range()).

*С#:*
```C#
class X {

	public int Y;
}
/**/
X a = new X();
a.Y = 1;
```
```C#
// "смотрите: настоящий ООП"
class X {
	private int _y;
	public int Y { // публичное свойство, нужны get и set
		set { _y = value; } // value - неявный параметр set
		get { return _y; }
	}
}
/*
*/
X a = new X();
a.Y = 1; // вызовется set с value=1, это не просто присваивание.
// наглядно реализовано в интерфейсах, например 
/*
window w; // нужно привязать окно к какой-то точке
w.x = 0; // на самом деле изменение геометрии не гарантируется, владелец окна может это запретить. значение меняются через get и set, но это скрыто от пользователя.
w.y = 1;
*/
int j = a.Y; // вызовется get
```
Некоторый дуализм данных и операций, но с точки зрения теории операции первичны.
? types are not values ? 

*Абстрактные типы данных* — АТД (ADT)

Данные харакатеризуют:

* Диапазон значений 
* Операции над ними (даже в большей степени!)

АТД характеризуют ОПЕРАЦИИ! (происходит отход от важности значений данных).

В чистых ОО ЯП АТД превратились в интерфейсы — "голые" сигнатуры операций (допускаются статические данные).
Когда придумывались АТД, имелось в виду, что описываться будут не только сигнатуры, но и свойства этих данных.
Например:
определим стек и операции в нем — pop(s, x) и push(s)
$$ \forall stack(s) \forall value(x)     push(s, x) => pop(s) = x $$

Есть типы данных (ТД). Есть объекты данных (над чем выполняются операции) Есть значения, каждое принадлежит какому-то ТП. Понятие "переменная" есть в любом ЯП. Отличие значения и переменной — (есть из переменной можно взять значение и можно его изменить — это императивная парадигма) у переменной есть имя, а значение, как правило, анонимно, например "3" — целый тип данных, но без имени. Можно дать имя значению, тогда это будет константа — частный случай переменной. Нотации не имеют понятия переменных: LAMBDA(X) (+ 1 X) — лямбда-функция, ее можно вызвать, вернуть. А если LAMBDA(X) (+ X Y) — Y переменная из области видимости:
```Lisp
// Lisp
(defun ADDX (Y)
	(LAMBDA (X) (+ X Y)) // Y 
)
```

``` JavaScript
// JavaScript
function addY(Y) {
	return X => X + Y
}
var f = addY(5) // f - функция, 5 оказалась захвачена в функции только на чтение, функциональное значение безымянно
f(2) // 7
// переменные с типом данных не связаны
```
В С# между типами данных есть отношение наследования, переменная принадлежит какому-то ТД, есть статический тип, который не изменяется, и есть динамический тип — то, что туда положили на самом деле. ССылка на значение — X a = new X() — a  становится ссылкой на значение, объектно-референциальный ЯП (C#, Java...). а может потом пменяться: a = new Y(), new Х() останется того же типа, так как анонимное значение, и потеряется, если не сохранить на него ссылку. Массивы тоже являются референциальными.

##### Область видимости (scope)
Связана с понятием имени
В том блоке, где объявлена. Или внутри класса (наследуемые классы образуют вложенные области видимости).
Все ЯП являются проективными (одна структура вкладывается в другую).
C именем связано понятие определяющего вхождения (декларация, определение).
Видимость тэгов структур в С — от определяющего вхождения до конца файла (даже если вложено).
```C
struct foo 
{
	int i;
	struct bar
	{
		int i;
		int foo;
	}
} foo, bar; // В С можно (для тэгов отдельная таблица), в С# и Java так нельзя
```
Нужна была совместимость с UNIX, а там есть struct time time.

Область видимости и несколько определяющих вхождений? Раньше могло быть только одно для каждого имени. Появление перегрузки для имен функций (верно почти для всех ЯП, где есть понятие перегрузки).
Понятие определяющего вхождения и использующего вхождения. В некоторых ЯП можно использовать переменные без декларации, как тогда определить, что это то самое определяющее вхождение? 
```JavaScript
function f(i) {
	if (i < 1) {
		x = 1 // что такое х?
	} // если транслятор увидит х, то он его перенесет выше как undefined, а потом задаст значение в ветке if. Но что тогда может быть в ветке else?
	else {...} // в некоторых расширениях JavaScript переменные обязаны быть определены (JSX)
}
```

##### Область действия (extent)
Связано с понятием значения (но не имени).
Являются проективными во всех ЯП (вложенность друг в друга).
В функциональных ЯП:
```
(defun f(x) (
	// тут х имеет одно значение
	)
) ( LET x () ) // переменная попала в захват и продолжит действовать (действует значение)
```
В императивных языках область действия распространяется и на переменные.
```JavaScript
function counter() {
	var n = 0
	return () => n++
}// вернет функциональное значение без параметров и захватит n, поэтому у n  будет область действия как и у возвращаемого функционального значения

...
counter()() // вернет 0
counter()() // тоже вернет 0, так как разные значения n

alert(counter()())// (вызов pop-up), вернет 0
alert(counter()())

var foo = counter()

alert(foo()) // 0
alert(foo()) // 1 - захвачено значение

```
Можно захватывать только read-only значения. 
В Java захват лямбдой переменной из внешней области разрешен только для final или effectively final переменных (констант или переменных, для которых компилятор может определить, что они являются константами)
**closure**
X => X + Y // захват переменной

 >В С++ throw, а не raise, потому что С++ писался под UNIX (должна была быть совместимость), а там raise — посылка сигнала самому себе.
 
 Все объекты данных имеют набор атрибутов. Например, в императивных ЯП — адрес
``` 
&v // C
v'ADDR // Ada
```

Можно передавать по значению и по ссылке
В функциональных ЯП нет такого понятия. Значение как-то передается (зависит от реализации), например, в Лиспе, атом — ссылка на таблицу атомов, передастся эта ссылка. **"Как хранятся, так и передаются"**
В императивных ЯП нужно четко понимать, ссылка это, или значение.

```Java
class X {
	public static void foo() {
		int i; // будет храниться в виде 4 байтов 
		Integer j = 1; // объект, класс-оболочка, в него завернуто значение, j — ссылка на анонимный объект в динамической памяти.
		int a[], b[]; // появилась ссылка
		a = new int[N]; // разместили массив в памяти
		b = a; // указывают на одно и то же
	}
}
```

##### Связывание (binding)

* Статическое связывание (до точки входа в программу)
```
static int i = 0; //(может осуществляться компоновщиком или загрузчиком)
```

* Квазистатическое связывание
Связывание локальных переменных с адресом (похоже на статическое, но формально происходит во время выполнения программы, вычисляется статическое смещение относительно регистра стека — между ESP и EBP)
```
void f(int i) {
	int j; 
} 
// в ассемблерном коде: (EBP - указатель конца фрейма на стеке)
asm {
	MOV EAX, j[EBP]
};

/* */
static int q = 0;
asm {
	MOV EBX, q
}
```
Все становится плохо, когда доходит до VLA (variable length array) в С99. Нужно к адресу а прибавлять длину а в байтах, и после нее загружать b. Мы не можем знать статическое смещение всех переменных в эом случае!
```
char a[i], b[i];
/**/
asm{
	MOV EAX, b[i[EBP]] // ???
}
```

```
// FORTRAN
SUBROUTINE P(N)
DIMENSION REAL A(N)
```

*C#:*
```
void foo(int i) 
{
	int[] a = new int[N];
	a[i] = 0; // квазистатическая проверка 0<=i<N, как если бы компилятор знал значение i
}
```
*С++ STL:*
"Бескомпромиссное стремление к эффективности": индексирование не проверяется, это не дает прибавку к эффективности. Проверяется только vec.at(i) (квазистатически).

* Динамическое связывание
Атрибут связывается со своим значением в момент выполнения.
Динамическое связывание адреса и динамических переменных.
 
